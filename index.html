<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/dendriform/_next/static/css/ba1d3b8a1304a7c43b03.css" as="style"/><link rel="stylesheet" href="/dendriform/_next/static/css/ba1d3b8a1304a7c43b03.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/dendriform/_next/static/chunks/main-a140d580cf631c156faf.js" as="script"/><link rel="preload" href="/dendriform/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/dendriform/_next/static/chunks/framework.8124b1ac1537ea0fac2e.js" as="script"/><link rel="preload" href="/dendriform/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.d7aae28dd68da61ed311.js" as="script"/><link rel="preload" href="/dendriform/_next/static/chunks/pages/_app-4f83bd40c0583f050ec4.js" as="script"/><link rel="preload" href="/dendriform/_next/static/chunks/pages/index-151a69b5a52a00e941c4.js" as="script"/><style data-styled="kxERWr OwFrU emIKKx gTIduj" data-styled-version="4.4.1">
/* sc-component-id: sc-bwzfXH */
.kxERWr{display:block;padding:16px;}.OwFrU{display:block;margin-top:16px;margin-bottom:128px;}.emIKKx{display:block;}.gTIduj{display:block;padding:8px;}</style></head><body><div id="__next"><div class="sc-bwzfXH kxERWr"><h1>dendriform demo</h1><div class="sc-bwzfXH OwFrU"><div style="background-color:rgb(157,219,239)" class="sc-bwzfXH emIKKx"><div class="sc-bwzfXH gTIduj">Top level... notice how it doesnt rerender because it didnt use .useValue() and therefore didnt opt in to receiving value updates, even though the useDendriform() hook holding the state lives in this component. This is going to be a **huge** perf boost</div><div class="sc-bwzfXH gTIduj">Tick: <!-- -->0<!-- --> seconds</div><div class="sc-bwzfXH gTIduj"><strong>Text inputs with debounce</strong><br/></div><div class="sc-bwzfXH gTIduj"><div style="background-color:rgb(214,161,211)" class="sc-bwzfXH gTIduj"><input value="a"/></div></div><div class="sc-bwzfXH gTIduj"><div style="background-color:rgb(238,222,195)" class="sc-bwzfXH gTIduj"><input value="a"/> and tick dependency: <!-- -->0<!-- --> seconds</div></div><div class="sc-bwzfXH gTIduj"><strong>Checkbox field</strong></div><div class="sc-bwzfXH gTIduj"><div style="background-color:rgb(224,197,247)" class="sc-bwzfXH gTIduj"><input type="checkbox" checked=""/></div></div><div class="sc-bwzfXH gTIduj"><strong>Select field</strong></div><div class="sc-bwzfXH gTIduj"><div style="background-color:rgb(236,221,255)" class="sc-bwzfXH gTIduj"><select><option value="grapefruit">Grapefruit</option><option value="lime">Lime</option><option value="coconut">Coconut</option><option value="mango">Mango</option></select></div></div><div class="sc-bwzfXH gTIduj"><strong>Array of fields</strong></div><div class="sc-bwzfXH gTIduj"><div style="background-color:rgb(226,226,230)" class="sc-bwzfXH gTIduj"><div style="background-color:rgb(164,222,203)" class="sc-bwzfXH gTIduj"><div style="background-color:rgb(244,193,226)" class="sc-bwzfXH gTIduj"><input value="oh no"/></div></div><div style="background-color:rgb(255,243,167)" class="sc-bwzfXH gTIduj"><div style="background-color:rgb(188,186,182)" class="sc-bwzfXH gTIduj"><input value="oh no!"/></div></div><div style="background-color:rgb(231,233,231)" class="sc-bwzfXH gTIduj"><div style="background-color:rgb(253,201,178)" class="sc-bwzfXH gTIduj"><input value="oh noo!"/></div></div></div><p>add pet</p><p>delete pet</p></div><div class="sc-bwzfXH gTIduj"><strong>Deep field calling produce() directly</strong></div><div class="sc-bwzfXH gTIduj"><div style="background-color:rgb(162,186,201)" class="sc-bwzfXH gTIduj"><p>Click to +3 - <!-- -->12</p></div></div><div class="sc-bwzfXH gTIduj"><strong>Calling produce() multiple times in a row</strong></div><div class="sc-bwzfXH gTIduj"><div style="background-color:rgb(216,227,203)" class="sc-bwzfXH gTIduj"><p>Click to +3 - <!-- -->12</p></div></div></div></div><pre>

- traverse your data like a tree âœ…
- traverse your data like a tree including arrays âœ…
- keeps original data in original shape âœ…
- a syntax that doesnt require a new component per field (even if it does this under the hood) âœ…
- full typescript support! âœ…
- api that allows components to &quot;opt in&quot; to React updates for way better perf âœ…
- non &quot;inner platform&quot; syntax for editing deep objects (immer) âœ…
- helpers for binding to inputs âœ…
- debounce changes âœ…
- getIn() âœ…

// SOON
- autokeyed children / rearrange arrays with immer and keep meta associated ðŸš€
- onChange
- derived data computation
- opt-in es6 class compatibility (may already exist with immer)
- change request details what fields have changed
- validation
- opt-in submit with failed request rollbacks
- ability to be controlled by higher up data sources including meta
  - need to make it possuble to prefill errors from back end response
- batch changes
- memoized branch creation

// LATER
- drag and drop array elements
- provide modifiers somehow to translate data from one format to another
- arbitrary metadata per field / path
- ability to rebase actions onto new source data
- undo / redo
- better focus control
- better integration with existing validation libs like yup
- chain a small form off a big one for submittable sub-forms
- can instanciate forms outside of react (probably already works, just haven&#x27;t tested it)
- able to output JSON patches for proper concurrent editing
- opt-in es6 Map and Set compatibility
- arbitrary metadata global to a form















// THINGS TO DITCH - DATAPARCELS POST-MORTEM

- immutable parcels
  - Problem: they inherently force unnecesary ancestor rerenders
  - Problem: React&#x27;s whole &quot;pass things down as props and let children decide when to update&quot;
             is a bit flawed, as child components are forced to have a bunch of non-declaritive
             and difficult to test code to determine if they shouldComponentUpdate(). Its duplicative,
             must be kept in sync with the data access, and nobody can be bothered.
             They should just let child components opt in to the type of updates they&#x27;re interested in
             and know if it should update based on that usage. Which is exactly what mobx does.
             (e.g. I want &quot;this component only cares about meta.error! ONLY UPDATE IF THAT BIT CHANGES&quot;)
  - Solution: share an unchanging ref to the form instance instead, from there opt in
              to binding to React&#x27;s reactions. Let entire layers of data not cause updates
              if the data at that level isnt actually used by the user for super performance
              (e.g. like mobx!)
  - Solution: provide a hook for each type of data to access (value. vs each type of meta), so usage
              is fine grained enough that re-renders can be reduced heaps WITHOUT touching
               shouldComponentUpdate() and duplicating the &quot;I want to use this&quot; type code that
               shouldComponentUpdate() or React.memo() normally wants you to write

- meta stored LITERALLY on each parcel:
  - Problem: leads to a difficult api for accessing these
  - Problem: inability to extend the idea to meta that doesnt belong to one single location path
  - Solution: meta as a Map() thats keyed on ids, very open and avaiable to all parcels in a tree

- only having hooks that provide state
  - Problem: your state must live in react. Sucks if you want to access anything outside React!
  - Problem: you get bound to executing things on React&#x27;s terms,
             which may not be the best choice, just the most obvious one
  - Solution: dont put so much of the useful stuff inside hooks, just allow them to be used with hooks

- upward propagation of changes through a chain of all parcels
  - Problem: nothing ever knows enough and concurrency gets annoying as different parts of the tree
             know different things
  - Problem: treating changes as a stream and batching change sets through time is too laggy
  - Problem: all parcels require unique keys not only on keypath, but each usage of that keypath which
             is almost impossible without imposing strange restrictions
  - Solution: dont do it. only MAYBE do this for debouncing purposes
  - Solution: if people want a submittable region halfway down a chain, make it easy to chain a new
              form off the existing one

- halfway-down-the-chain modifiers:
  - Problem: soo much internal juggling and esoteric usage patterns came about because of this one small idea
  - Problem: knowledge of these modifiers isnt known up at the top where its needed half the time
  - Solution: config these at the top??? what if two inputs want different modifiers? Needs more thought

- changing data via un-codesplittable methods
  - Problem: methods on a class arent code-splittable
  - Solution: use immer, it does what the inside of dataparcels was trying to do, but way better
  - Solution: make people import fancy methods for changing

- roll-your-own history system
  - Problem: lots of code to maintain and tests to write
  - Solution: use immer, it does what the inside of dataparcels was trying to do, but way better

- inner platform syndrome
  - Problem: seems like parcels has too many array methods, but also doesnt have all of them :/
  - Solution: use immer, it does what the inside of dataparcels was trying to do, but way better

- the promise to be extensible enough to cope with any data type
  - Problem: becomes way more difficult to leverage other libraries that deal specifically with immutable state changes
  - Solution: dont make that promise, and defer the decision to someone else (e.g. immer)

- Generic package and a react package
  - Problem: the internal split surfaces as a slightly more complicated api, and im never really planning to work on
             or use a non-react version. cross that bridge if we need to later
  - Solution: single package, way more succint API!

- providing a bunch of preset pathways for submit / onChange / update and forcing people to use them can be awkward
  - Solution: hooks exist, get the user to use them OUTSIDE the library to solve the issue
</pre></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/","query":{},"buildId":"mzDItEklyv_mvgfQOAPUB","assetPrefix":"/dendriform","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/dendriform/_next/static/chunks/polyfills-36bde18dcfde0c144be5.js"></script><script src="/dendriform/_next/static/chunks/main-a140d580cf631c156faf.js" async=""></script><script src="/dendriform/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/dendriform/_next/static/chunks/framework.8124b1ac1537ea0fac2e.js" async=""></script><script src="/dendriform/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.d7aae28dd68da61ed311.js" async=""></script><script src="/dendriform/_next/static/chunks/pages/_app-4f83bd40c0583f050ec4.js" async=""></script><script src="/dendriform/_next/static/chunks/pages/index-151a69b5a52a00e941c4.js" async=""></script><script src="/dendriform/_next/static/mzDItEklyv_mvgfQOAPUB/_buildManifest.js" async=""></script><script src="/dendriform/_next/static/mzDItEklyv_mvgfQOAPUB/_ssgManifest.js" async=""></script></body></html>